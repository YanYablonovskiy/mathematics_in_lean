import Mathlib.Tactic
import Mathlib.Util.Delaborators
import Mathlib.Algebra.BigOperators.Ring
import Mathlib.Data.Real.Basic

set_option autoImplicit true


class One‚ÇÅ (Œ± : Type) where
  /-- The element one -/
  one : Œ±

class One·µ¢ (Œ± : Type) where
  /-- The element one -/
  one : Œ±

#check One‚ÇÅ.one -- One‚ÇÅ.one {Œ± : Type} [self : One‚ÇÅ Œ±] : Œ±

@[class] structure One‚ÇÇ (Œ± : Type) where
  /-- The element one -/
  one : Œ± --a type?

#check One‚ÇÇ.one -- One‚ÇÇ.one {Œ± : Type} (self : One‚ÇÇ Œ±) : Œ±

section
variable (Œ≤: Type) [B: One‚ÇÇ Œ≤]

#check One‚ÇÇ.one B


end

example (Œ± : Type) [One‚ÇÅ Œ±] : Œ± := One‚ÇÅ.one

example (Œ± : Type) [One‚ÇÅ Œ±] := (One‚ÇÅ.one : Œ±)

@[inherit_doc]
notation "ùüô" => One‚ÇÅ.one

example {Œ± : Type} [One‚ÇÅ Œ±] : Œ± := ùüô

example {Œ± : Type} [One‚ÇÅ Œ±] : (ùüô : Œ±) = ùüô := rfl


class Dia‚ÇÅ (Œ± : Type) where
  dia : Œ± ‚Üí Œ± ‚Üí Œ±

infixl:70 " ‚ãÑ "   => Dia‚ÇÅ.dia

/-
As in the One‚ÇÅ example, the operation has no property at all at this stage.

Let us now define the class of semigroup structures where the operation is denoted by ‚ãÑ.

For now, we define it by hand as a structure with two fields, a Dia‚ÇÅ instance and some Prop-valued field dia_assoc asserting associativity of ‚ãÑ.
-/


class Semigroup‚ÇÅ (Œ± : Type) where
  toDia‚ÇÅ : Dia‚ÇÅ Œ±
  /-- Diamond is associative -/
  dia_assoc : ‚àÄ a b c : Œ±, a ‚ãÑ b ‚ãÑ c = a ‚ãÑ (b ‚ãÑ c)
/-
Note that while stating dia_assoc, the previously defined field toDia‚ÇÅ is in the local context hence can be used when
Lean searches for an instance of Dia‚ÇÅ Œ± to make sense of a ‚ãÑ b.

However this toDia‚ÇÅ field does not become part of the type class instances database.

Hence doing example {Œ± : Type} [Semigroup‚ÇÅ Œ±] (a b : Œ±) : Œ± := a ‚ãÑ b would fail with error message failed to synthesize instance Dia‚ÇÅ Œ±.

We can fix this by adding the instance attribute later.
-/

attribute [instance] Semigroup‚ÇÅ.toDia‚ÇÅ  --on Œ±

example {Œ± : Type} [Semigroup‚ÇÅ Œ±] (a b : Œ±) : Œ± := a ‚ãÑ b

example {Œ± : Type} [Semigroup‚ÇÅ Œ±] (a b : Œ±) := (a ‚ãÑ b: Œ±)

/-
Before building up, we need a more convenient way to extend structures than explicitly writing fields like toDia‚ÇÅ and adding the instance attribute by hand.

The class supports this using the extends syntax as in:
-/


/-
Instead of field toDia‚ÇÅ : Dia‚ÇÅ Œ± + attribute [instance] Semigroup‚ÇÅ.toDia‚ÇÅ
-/
class Semigroup‚ÇÇ (Œ± : Type) extends Dia‚ÇÅ Œ± where
  /-- Diamond is associative -/
  dia_assoc : ‚àÄ a b c : Œ±, a ‚ãÑ b ‚ãÑ c = a ‚ãÑ (b ‚ãÑ c)


#print Semigroup‚ÇÇ
-- Semigroup‚ÇÇ.mk : {Œ± : Type} ‚Üí [toDia‚ÇÅ : Dia‚ÇÅ Œ±] ‚Üí (‚àÄ (a b c : Œ±), a ‚ãÑ b ‚ãÑ c = a ‚ãÑ (b ‚ãÑ c)) ‚Üí Semigroup‚ÇÇ Œ±

example {Œ± : Type} [Semigroup‚ÇÇ Œ±] (a b : Œ±) : Œ± := a ‚ãÑ b


/-
Note this syntax is also available in the structure command, although it that case it fixes only the hurdle of writing fields such as toDia‚ÇÅ
since there is no instance to define in that case.

Let us now try to combine a diamond operation and a distinguished one with axioms saying this element is neutral on both sides.
-/
class DiaOneClass‚ÇÅ (Œ± : Type) extends One‚ÇÅ Œ±, Dia‚ÇÅ Œ± where
  /-- One is a left neutral element for diamond. -/
  one_dia : ‚àÄ a : Œ±, ùüô ‚ãÑ a = a
  /-- One is a right neutral element for diamond -/
  dia_one : ‚àÄ a : Œ±, a ‚ãÑ ùüô = a


/-
In the next example, we tell Lean that Œ± has a DiaOneClass‚ÇÅ structure and state a property that uses both a Dia‚ÇÅ instance and a One‚ÇÅ instance.

In order to see how Lean finds those instances we set a tracing option whose result can be seen in the Infoview.

This result is rather terse by default but it can be expanded by clicking on lines ending with black arrows.

It includes failed attempts where Lean tried to find instances before having enough type information to succeed.

The successful attempts do involve the instances generated by the extends syntax.
-/


set_option trace.Meta.synthInstance true in
example {Œ± : Type} [DiaOneClass‚ÇÅ Œ±] (a b : Œ±) : Prop := a ‚ãÑ b = ùüô

/-
Note that we don‚Äôt need to include extra fields where combining existing classes.

Hence we can define monoids as:
-/

class Monoid‚ÇÅ (Œ± : Type) extends Semigroup‚ÇÅ Œ±, DiaOneClass‚ÇÅ Œ±

/-
While the above definition seems straightforward, it hides an important subtlety.

Both Semigroup‚ÇÅ Œ± and DiaOneClass‚ÇÅ Œ± extend Dia‚ÇÅ Œ±, so one could fear that having a Monoid‚ÇÅ Œ± instance gives two unrelated diamond operations on Œ±,
one coming from a field Monoid‚ÇÅ.toSemigroup‚ÇÅ and one coming from a field Monoid‚ÇÅ.toDiaOneClass‚ÇÅ.

Indeed if we try to build a monoid class by hand using:
-/


--Indeed if we try to build a monoid class by hand using:
class Monoid‚ÇÇ (Œ± : Type) where
  toSemigroup‚ÇÅ : Semigroup‚ÇÅ Œ±
  toDiaOneClass‚ÇÅ : DiaOneClass‚ÇÅ Œ±

/-
then we get two completely unrelated diamond operations Monoid‚ÇÇ.toSemigroup‚ÇÅ.toDia‚ÇÅ.dia and Monoid‚ÇÇ.toDiaOneClass‚ÇÅ.toDia‚ÇÅ.dia.

The version generated using the extends syntax does not have this defect.
-/
example {Œ± : Type} [Monoid‚ÇÅ Œ±] :
  (Monoid‚ÇÅ.toSemigroup‚ÇÅ.toDia‚ÇÅ.dia : Œ± ‚Üí Œ± ‚Üí Œ±) = Monoid‚ÇÅ.toDiaOneClass‚ÇÅ.toDia‚ÇÅ.dia := rfl

/-
So the class command did some magic for us (and the structure command would have done it too).

An easy way to see what are the fields of our classes is to check their constructor. Compare:
-/

/- Monoid‚ÇÇ.mk {Œ± : Type} (toSemigroup‚ÇÅ : Semigroup‚ÇÅ Œ±) (toDiaOneClass‚ÇÅ : DiaOneClass‚ÇÅ Œ±) : Monoid‚ÇÇ Œ± -/
#check Monoid‚ÇÇ.mk

/- Monoid‚ÇÅ.mk {Œ± : Type} [toSemigroup‚ÇÅ : Semigroup‚ÇÅ Œ±] [toOne‚ÇÅ : One‚ÇÅ Œ±] (one_dia : ‚àÄ (a : Œ±), ùüô ‚ãÑ a = a) (dia_one : ‚àÄ (a : Œ±), a ‚ãÑ ùüô = a) : Monoid‚ÇÅ Œ± -/
#check Monoid‚ÇÅ.mk

/-
So we see that Monoid‚ÇÅ takes Semigroup‚ÇÅ Œ± argument as expected but then it won‚Äôt take a would-be overlapping DiaOneClass‚ÇÅ Œ± argument
but instead tears it apart and includes only the non-overlapping parts.

And it also auto-generated an instance Monoid‚ÇÅ.toDiaOneClass‚ÇÅ which is not a field but has the expected signature which,
from the end-user point of view, restores the symmetry between the two extended classes Semigroup‚ÇÅ and DiaOneClass‚ÇÅ.
-/
#check Monoid‚ÇÅ.toSemigroup‚ÇÅ
#check Monoid‚ÇÅ.toDiaOneClass‚ÇÅ

/-
We are now very close to defining groups.

We could add to the monoid structure a field asserting the existence of an inverse for every element.

But then we would need to work to access these inverses.

In practice it is more convenient to add it as data.

To optimize reusability, we define a new data-carrying class, and then give it some notation.
-/

class Inv‚ÇÅ (Œ± : Type) where
  /-- The inversion function -/
  inv : Œ± ‚Üí Œ±

@[inherit_doc]
postfix:max "‚Åª¬π" => Inv‚ÇÅ.inv

class Group‚ÇÅ (G : Type) extends Monoid‚ÇÅ G, Inv‚ÇÅ G where
  inv_dia : ‚àÄ a : G, a‚Åª¬π ‚ãÑ a = ùüô
/-
The above definition may seem too weak, we only ask that a‚Åª¬π is a left-inverse of a.
But the other side is automatic. In order to prove that, we need a preliminary lemma.
-/

lemma left_inv_eq_right_inv‚ÇÅ {M : Type} [Monoid‚ÇÅ M] {a b c : M} (hba : b ‚ãÑ a = ùüô) (hac : a ‚ãÑ c = ùüô) : b = c := by
  rw [‚Üê DiaOneClass‚ÇÅ.one_dia c, ‚Üê hba, Semigroup‚ÇÅ.dia_assoc, hac, DiaOneClass‚ÇÅ.dia_one b]

/-
In this lemma, it is pretty annoying to give full names, especially since it requires knowing which part of the hierarchy provides those facts.

One way to fix this is to use the export command to copy those facts as lemmas in the root name space.
-/

export DiaOneClass‚ÇÅ (one_dia dia_one)
export Semigroup‚ÇÅ (dia_assoc)
export Group‚ÇÅ (inv_dia)


example {M : Type} [Monoid‚ÇÅ M] {a b c : M} (hba : b ‚ãÑ a = ùüô) (hac : a ‚ãÑ c = ùüô) : b = c := by
  rw [‚Üê one_dia c, ‚Üê hba, dia_assoc, hac, dia_one b]

#check left_inv_eq_right_inv‚ÇÅ

lemma inv_eq_of_dia [Group‚ÇÅ G] {a b : G} (h : a ‚ãÑ b = ùüô) : a‚Åª¬π = b := by
 apply left_inv_eq_right_inv‚ÇÅ (a := a)
 . rw [inv_dia]
 . exact h

lemma dia_inv [Group‚ÇÅ G] (a : G) : a ‚ãÑ a‚Åª¬π = ùüô := by
 rw [‚Üêinv_dia a‚Åª¬π]
 have: a‚Åª¬π‚Åª¬π = a := by
  apply inv_eq_of_dia
  . exact inv_dia a
 rw [this]










class AddSemigroup‚ÇÉ (Œ± : Type) extends Add Œ± where
/-- Addition is associative -/
  add_assoc‚ÇÉ : ‚àÄ a b c : Œ±, a + b + c = a + (b + c)

@[to_additive AddSemigroup‚ÇÉ]
class Semigroup‚ÇÉ (Œ± : Type) extends Mul Œ± where
/-- Multiplication is associative -/
  mul_assoc‚ÇÉ : ‚àÄ a b c : Œ±, a * b * c = a * (b * c)

class AddMonoid‚ÇÉ (Œ± : Type) extends AddSemigroup‚ÇÉ Œ±, AddZeroClass Œ±

@[to_additive AddMonoid‚ÇÉ]
class Monoid‚ÇÉ (Œ± : Type) extends Semigroup‚ÇÉ Œ±, MulOneClass Œ±

attribute [to_additive existing] Monoid‚ÇÉ.toMulOneClass

export Semigroup‚ÇÉ (mul_assoc‚ÇÉ)
export AddSemigroup‚ÇÉ (add_assoc‚ÇÉ)

whatsnew in
@[to_additive]
lemma left_inv_eq_right_inv' {M : Type} [Monoid‚ÇÉ M] {a b c : M} (hba : b * a = 1) (hac : a * c = 1) : b = c := by
  rw [‚Üê one_mul c, ‚Üê hba, mul_assoc‚ÇÉ, hac, mul_one b]

#check left_neg_eq_right_neg'

class AddCommSemigroup‚ÇÉ (Œ± : Type) extends AddSemigroup‚ÇÉ Œ± where
  add_comm : ‚àÄ a b : Œ±, a + b = b + a

@[to_additive AddCommSemigroup‚ÇÉ]
class CommSemigroup‚ÇÉ (Œ± : Type) extends Semigroup‚ÇÉ Œ± where
  mul_comm : ‚àÄ a b : Œ±, a * b = b * a

class AddCommMonoid‚ÇÉ (Œ± : Type) extends AddMonoid‚ÇÉ Œ±, AddCommSemigroup‚ÇÉ Œ±

@[to_additive AddCommMonoid‚ÇÉ]
class CommMonoid‚ÇÉ (Œ± : Type) extends Monoid‚ÇÉ Œ±, CommSemigroup‚ÇÉ Œ±

class AddGroup‚ÇÉ (G : Type) extends AddMonoid‚ÇÉ G, Neg G where
  neg_add : ‚àÄ a : G, -a + a = 0

@[to_additive AddGroup‚ÇÉ]
class Group‚ÇÉ (G : Type) extends Monoid‚ÇÉ G, Inv G where
  inv_mul : ‚àÄ a : G, a‚Åª¬π * a = 1


attribute [simp] Group‚ÇÉ.inv_mul AddGroup‚ÇÉ.neg_add



@[to_additive]
lemma inv_eq_of_mul [Group‚ÇÉ G] {a b : G} (h : a * b = 1) : a‚Åª¬π = b :=
  sorry


@[to_additive (attr := simp)]
lemma Group‚ÇÉ.mul_inv {G : Type} [Group‚ÇÉ G] {a : G} : a * a‚Åª¬π = 1 := by
  sorry

@[to_additive]
lemma mul_left_cancel‚ÇÉ {G : Type} [Group‚ÇÉ G] {a b c : G} (h : a * b = a * c) : b = c := by
  sorry

@[to_additive]
lemma mul_right_cancel‚ÇÉ {G : Type} [Group‚ÇÉ G] {a b c : G} (h : b*a = c*a) : b = c := by
  sorry

class AddCommGroup‚ÇÉ (G : Type) extends AddGroup‚ÇÉ G, AddCommMonoid‚ÇÉ G

@[to_additive AddCommGroup‚ÇÉ]
class CommGroup‚ÇÉ (G : Type) extends Group‚ÇÉ G, CommMonoid‚ÇÉ G



class Ring‚ÇÉ (R : Type) extends AddGroup‚ÇÉ R, Monoid‚ÇÉ R, MulZeroClass R where
  /-- Multiplication is left distributive over addition -/
  left_distrib : ‚àÄ a b c : R, a * (b + c) = a * b + a * c
  /-- Multiplication is right distributive over addition -/
  right_distrib : ‚àÄ a b c : R, (a + b) * c = a * c + b * c

instance {R : Type} [Ring‚ÇÉ R] : AddCommGroup‚ÇÉ R :=
{ Ring‚ÇÉ.toAddGroup‚ÇÉ with
  add_comm := by
    sorry }

instance : Ring‚ÇÉ ‚Ñ§ where
  add := (¬∑ + ¬∑)
  add_assoc‚ÇÉ := add_assoc
  zero := 0
  zero_add := by simp
  add_zero := by simp
  neg := (- ¬∑)
  neg_add := by simp
  mul := (¬∑ * ¬∑)
  mul_assoc‚ÇÉ := mul_assoc
  one := 1
  one_mul := by simp
  mul_one := by simp
  zero_mul := by simp
  mul_zero := by simp
  left_distrib := Int.mul_add
  right_distrib := Int.add_mul

class LE‚ÇÅ (Œ± : Type) where
  /-- The Less-or-Equal relation. -/
  le : Œ± ‚Üí Œ± ‚Üí Prop

@[inherit_doc] infix:50 " ‚â§‚ÇÅ " => LE‚ÇÅ.le

class Preorder‚ÇÅ (Œ± : Type)

class PartialOrder‚ÇÅ (Œ± : Type)

class OrderedCommMonoid‚ÇÅ (Œ± : Type)

instance : OrderedCommMonoid‚ÇÅ ‚Ñï where

class SMul‚ÇÉ (Œ± : Type) (Œ≤ : Type) where
  /-- Scalar multiplication -/
  smul : Œ± ‚Üí Œ≤ ‚Üí Œ≤

infixr:73 " ‚Ä¢ " => SMul‚ÇÉ.smul


class Module‚ÇÅ (R : Type) [Ring‚ÇÉ R] (M : Type) [AddCommGroup‚ÇÉ M] extends SMul‚ÇÉ R M where
  zero_smul : ‚àÄ m : M, (0 : R) ‚Ä¢ m = 0
  one_smul : ‚àÄ m : M, (1 : R) ‚Ä¢ m = m
  mul_smul : ‚àÄ (a b : R) (m : M), (a * b) ‚Ä¢ m = a ‚Ä¢ b ‚Ä¢ m
  add_smul : ‚àÄ (a b : R) (m : M), (a + b) ‚Ä¢ m = a ‚Ä¢ m + b ‚Ä¢ m
  smul_add : ‚àÄ (a : R) (m n : M), a ‚Ä¢ (m + n) = a ‚Ä¢ m + a ‚Ä¢ n

instance selfModule (R : Type) [Ring‚ÇÉ R] : Module‚ÇÅ R R where
  smul := fun r s ‚Ü¶ r*s
  zero_smul := zero_mul
  one_smul := one_mul
  mul_smul := mul_assoc‚ÇÉ
  add_smul := Ring‚ÇÉ.right_distrib
  smul_add := Ring‚ÇÉ.left_distrib

def nsmul‚ÇÅ [Zero M] [Add M] : ‚Ñï ‚Üí M ‚Üí M
  | 0, _ => 0
  | n + 1, a => a + nsmul‚ÇÅ n a

def zsmul‚ÇÅ {M : Type*} [Zero M] [Add M] [Neg M] : ‚Ñ§ ‚Üí M ‚Üí M
  | Int.ofNat n, a => nsmul‚ÇÅ n a
  | Int.negSucc n, a => -nsmul‚ÇÅ n.succ a

instance abGrpModule (A : Type) [AddCommGroup‚ÇÉ A] : Module‚ÇÅ ‚Ñ§ A where
  smul := zsmul‚ÇÅ
  zero_smul := sorry
  one_smul := sorry
  mul_smul := sorry
  add_smul := sorry
  smul_add := sorry

#synth Module‚ÇÅ ‚Ñ§ ‚Ñ§ -- abGrpModule ‚Ñ§


class AddMonoid‚ÇÑ (M : Type) extends AddSemigroup‚ÇÉ M, AddZeroClass M where
  /-- Multiplication by a natural number. -/
  nsmul : ‚Ñï ‚Üí M ‚Üí M := nsmul‚ÇÅ
  /-- Multiplication by `(0 : ‚Ñï)` gives `0`. -/
  nsmul_zero : ‚àÄ x, nsmul 0 x = 0 := by intros; rfl
  /-- Multiplication by `(n + 1 : ‚Ñï)` behaves as expected. -/
  nsmul_succ : ‚àÄ (n : ‚Ñï) (x), nsmul (n + 1) x = x + nsmul n x := by intros; rfl

instance mySMul {M : Type} [AddMonoid‚ÇÑ M] : SMul ‚Ñï M := ‚ü®AddMonoid‚ÇÑ.nsmul‚ü©

instance (M N : Type) [AddMonoid‚ÇÑ M] [AddMonoid‚ÇÑ N] : AddMonoid‚ÇÑ (M √ó N) where
  add := fun p q ‚Ü¶ (p.1 + q.1, p.2 + q.2)
  add_assoc‚ÇÉ := fun a b c ‚Ü¶ by ext <;> apply add_assoc‚ÇÉ
  zero := (0, 0)
  zero_add := fun a ‚Ü¶ by ext <;> apply zero_add
  add_zero := fun a ‚Ü¶ by ext <;> apply add_zero

instance : AddMonoid‚ÇÑ ‚Ñ§ where
  add := (¬∑ + ¬∑)
  add_assoc‚ÇÉ := Int.add_assoc
  zero := 0
  zero_add := Int.zero_add
  add_zero := Int.add_zero
  nsmul := fun n m ‚Ü¶ (n : ‚Ñ§) * m
  nsmul_zero := Int.zero_mul
  nsmul_succ := fun n m ‚Ü¶ show (n + 1 : ‚Ñ§) * m = m + n * m
    by rw [Int.add_mul, Int.add_comm, Int.one_mul]

example (n : ‚Ñï) (m : ‚Ñ§) : SMul.smul (self := mySMul) n m = n * m := rfl
